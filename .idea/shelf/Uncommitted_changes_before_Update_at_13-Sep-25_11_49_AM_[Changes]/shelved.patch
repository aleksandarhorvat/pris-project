Index: fpga_project/fpga_routing.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\r\nfrom bokeh.colors.named import lemonchiffon\r\nimport random\r\nfrom matplotlib import patches\r\n\r\nfrom .fpga_matrix import FPGAMatrix\r\nfrom .models import RRG\r\n\r\n\r\nclass FPGARouting(FPGAMatrix):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n    def visualize_routing_on_grid(self, rrg: RRG, routing_path, net_id=None):\r\n        self.routing_path = routing_path\r\n        self.net_id = net_id\r\n\r\n        self.draw_routing_path_on_grid(rrg)\r\n\r\n    def draw_routing_path_on_grid(self, rrg: RRG):\r\n        if not self.routing_path:\r\n            print(\"Nemamo rutu\")\r\n            return\r\n\r\n        # pratimo edges da bi izbegli duplikate\r\n        drawn_edges = set()\r\n        x_coords = []\r\n        y_coords = []\r\n        node_ids = []\r\n        arrow_positions = []\r\n\r\n        # pratimo putanju signala, tj. lista nodova\r\n        signal_flow = {}\r\n\r\n        # pravimo rutu\r\n        for i in range(len(self.routing_path) - 1):\r\n            node_id1 = self.routing_path[i]\r\n            node_id2 = self.routing_path[i + 1]\r\n\r\n            if node_id1 not in signal_flow:\r\n                signal_flow[node_id1] = []\r\n            signal_flow[node_id1].append(node_id2)\r\n\r\n        # skupljamo sve sinkove\r\n        sink_nodes = []\r\n        for node_id in self.routing_path:\r\n            if rrg.nodes[node_id].type == \"SINK\":\r\n                if node_id in self.coord_map:\r\n                    sink_nodes.append((node_id, self.coord_map[node_id]))\r\n\r\n        for i in range(len(self.routing_path) - 1):\r\n            node_id1 = self.routing_path[i]\r\n            node_id2 = self.routing_path[i + 1]\r\n\r\n            if (rrg.nodes[node_id1].type == \"SINK\" or\r\n                    rrg.nodes[node_id2].type == \"SINK\"):\r\n                continue\r\n\r\n            if node_id1 not in self.coord_map or node_id2 not in self.coord_map:\r\n                print(f\"Upozorenje: Node {node_id1} ili {node_id2} nije na coord_map\")\r\n                continue\r\n\r\n            x1, y1 = self.coord_map[node_id1]\r\n            x2, y2 = self.coord_map[node_id2]\r\n\r\n            node1 = rrg.nodes[node_id1]\r\n            node2 = rrg.nodes[node_id2]\r\n\r\n            # ovaj deo dole se bavi onim preskakanjem kada imamo povratnu putanju\r\n            if i == 0:\r\n                x_coords.append(x1)\r\n                y_coords.append(y1)\r\n                node_ids.append(node_id1)\r\n            x_coords.append(x2)\r\n            y_coords.append(y2)\r\n            node_ids.append(node_id2)\r\n\r\n            edge_key = (node_id1, node_id2)\r\n            if edge_key in drawn_edges:\r\n                continue\r\n            drawn_edges.add(edge_key)\r\n\r\n            # racunamo vektor u kom smeru cemo nacrtati strelice\r\n            dx = x2 - x1\r\n            dy = y2 - y1\r\n            length = (dx ** 2 + dy ** 2) ** 0.5\r\n            if length > 0:\r\n                dx_norm = dx / length\r\n                dy_norm = dy / length\r\n            else:\r\n                dx_norm, dy_norm = 0, 0\r\n\r\n            # ovde nam je crtanje rute podeljeno po segmentima u zavisnosti sta se povezuje, isto vazi i za crtanje strelica\r\n            # io veze - direktna linija\r\n            if node1.type == 'IO' or node2.type == 'IO':\r\n                self.ax.plot([x1, x2], [y1, y2],\r\n                             color=self.colors['ROUTED_PATH'], linewidth=2, alpha=0.9)\r\n                # dodajemo strelice na 70% ovog segementa\r\n                arrow_x = x1 + 0.7 * dx\r\n                arrow_y = y1 + 0.7 * dy\r\n                arrow_positions.append((arrow_x, arrow_y, dx_norm, dy_norm))\r\n\r\n            # kanal-kanal veza\r\n            if node1.type in ['CHANX', 'CHANY'] and node2.type in ['CHANX', 'CHANY']:\r\n                # ista vrsta kanala - direktna linija\r\n                if node1.type == node2.type:\r\n                    self.ax.plot([x1, x2], [y1, y2],\r\n                                 color=self.colors['ROUTED_PATH'], linewidth=2, alpha=0.9)\r\n                    # dodajemo strelice na 70% ovog segementa\r\n                    arrow_x = x1 + 0.7 * dx\r\n                    arrow_y = y1 + 0.7 * dy\r\n                    arrow_positions.append((arrow_x, arrow_y, dx_norm, dy_norm))\r\n                else:\r\n                    # razlicita vrsta kanala - L-oblik\r\n                    # Pronađi tačku preseka (sredinu kanala)\r\n                    if node1.type == 'CHANX':  # horizontalni -> vertikalni\r\n                        # Koristimo x koordinatu vertikalnog kanala i y koordinatu horizontalnog kanala\r\n                        turn_x = x2\r\n                        turn_y = y1\r\n                    else:  # vertikalni -> horizontalni\r\n                        # Koristimo x koordinatu vertikalnog kanala i y koordinatu horizontalnog kanala\r\n                        turn_x = x1\r\n                        turn_y = y2\r\n\r\n                    # Crtamo L-oblik: prvi segment do tačke okreta, pa drugi segment\r\n                    self.ax.plot([x1, turn_x], [y1, turn_y],\r\n                                 color=self.colors['ROUTED_PATH'], linewidth=2, alpha=0.9)\r\n                    self.ax.plot([turn_x, x2], [turn_y, y2],\r\n                                 color=self.colors['ROUTED_PATH'], linewidth=2, alpha=0.9)\r\n\r\n                    # dodajemo strelice za oba smera crtanja\r\n                    # prvi smer - do okreta\r\n                    seg1_dx = turn_x - x1\r\n                    seg1_dy = turn_y - y1\r\n                    seg1_length = (seg1_dx ** 2 + seg1_dy ** 2) ** 0.5\r\n                    if seg1_length > 0:\r\n                        seg1_dx_norm = seg1_dx / seg1_length\r\n                        seg1_dy_norm = seg1_dy / seg1_length\r\n                    else:\r\n                        seg1_dx_norm, seg1_dy_norm = 0, 0\r\n\r\n                    arrow_x1 = x1 + 0.7 * seg1_dx\r\n                    arrow_y1 = y1 + 0.7 * seg1_dy\r\n                    arrow_positions.append((arrow_x1, arrow_y1, seg1_dx_norm, seg1_dy_norm))\r\n\r\n                    # drugi smer - od okreta\r\n                    seg2_dx = x2 - turn_x\r\n                    seg2_dy = y2 - turn_y\r\n                    seg2_length = (seg2_dx ** 2 + seg2_dy ** 2) ** 0.5\r\n                    if seg2_length > 0:\r\n                        seg2_dx_norm = seg2_dx / seg2_length\r\n                        seg2_dy_norm = seg2_dy / seg2_length\r\n                    else:\r\n                        seg2_dx_norm, seg2_dy_norm = 0, 0\r\n\r\n                    arrow_x2 = turn_x + 0.7 * seg2_dx\r\n                    arrow_y2 = turn_y + 0.7 * seg2_dy\r\n                    arrow_positions.append((arrow_x2, arrow_y2, seg2_dx_norm, seg2_dy_norm))\r\n\r\n            else:\r\n                # pin-kanal ili kanal-pin veza - direktna linija\r\n                self.ax.plot([x1, x2], [y1, y2],\r\n                             color=self.colors['ROUTED_PATH'], linewidth=2, alpha=0.9)\r\n                # dodajemo strelice na 70% ovog segementa\r\n                arrow_x = x1 + 0.7 * dx\r\n                arrow_y = y1 + 0.7 * dy\r\n                arrow_positions.append((arrow_x, arrow_y, dx_norm, dy_norm))\r\n\r\n        # sve strelice\r\n        for arrow_x, arrow_y, dx_norm, dy_norm in arrow_positions:\r\n            # crtamo samo ako imamo dobar smer\r\n            if dx_norm != 0 or dy_norm != 0:\r\n                # duzina repa strelice da ne bude predugacko\r\n                tail_length = 0.05\r\n                self.ax.arrow(arrow_x, arrow_y, dx_norm * tail_length, dy_norm * tail_length, head_width=0.09,\r\n                              head_length=0.09,\r\n                              fc=self.colors['ROUTED_PATH'],\r\n                              ec=self.colors['ROUTED_PATH'])\r\n\r\n        # labele za source\r\n        if len(node_ids) >= 2:\r\n            self.ax.text(x_coords[0], y_coords[0] - 0.3, f'{node_ids[0]}',\r\n                         ha='center', va='center', fontsize=7,\r\n                         bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"lightblue\"))\r\n\r\n        # labele za sve sink\r\n        for node_id, (x, y) in sink_nodes:\r\n            self.ax.text(x, y - 0.3, f'{node_id}',\r\n                         ha='center', va='center', fontsize=7,\r\n                         bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"lightgreen\"))\r\n\r\n    def visualize_routing_by_branching(self, rrg: RRG, route_data, branching_factor: int):\r\n        if not route_data.nets:\r\n            print(\"Nema netova\")\r\n            return       \r\n        # lista svih routing pathova za crtanje\r\n        all_routing_paths = []\r\n\r\n        for net_id, net in route_data.nets.items():\r\n            num_sinks = sum(1 for node in net.nodes if node.type == \"SINK\")\r\n            if num_sinks != branching_factor:\r\n                continue  # preskocimo netove koji ne zadovoljavaju faktor\r\n\r\n            routing_path = [node.id for node in net.nodes]\r\n            all_routing_paths.append((routing_path, net_id))\r\n\r\n        # pozivamo draw metodu sa svim routing pathovima\r\n        self.draw_branching_paths_on_grid(rrg, all_routing_paths)\r\n\r\n    \r\n    def draw_branching_paths_on_grid(self, rrg: RRG, all_routing_paths: list):\r\n        if not all_routing_paths:\r\n            print(\"Nema ruta za crtanje\")\r\n            return\r\n        \r\n        labeled_positions = {}\r\n        \r\n        colors = {}\r\n        for _, net_id in all_routing_paths:\r\n            colors[net_id] = (random.random(), random.random(), random.random())\r\n        \r\n            \r\n        for routing_path, net_id in all_routing_paths:\r\n            drawn_edges = set()\r\n            arrow_positions = []\r\n            x_coords, y_coords = [], []\r\n\r\n            for i in range(len(routing_path) - 1):\r\n                node_id1 = routing_path[i]\r\n                node_id2 = routing_path[i + 1]\r\n\r\n                node1 = rrg.nodes[node_id1]\r\n                node2 = rrg.nodes[node_id2]\r\n\r\n                if (rrg.nodes[node_id1].type == \"SINK\" or\r\n                    rrg.nodes[node_id2].type == \"SINK\"):\r\n                    continue\r\n\r\n                if node_id1 not in self.coord_map or node_id2 not in self.coord_map:\r\n                    print(f\"Upozorenje: Node {node_id1} ili {node_id2} nije na coord_map\")\r\n                    continue\r\n                \r\n                \r\n                x1, y1 = self.coord_map[node_id1]\r\n                x2, y2 = self.coord_map[node_id2]\r\n\r\n                if node2.type == \"SINK\":\r\n                    self.ax.plot([x1, x2], [y1, y2], color=colors[net_id], linewidth=2, alpha=0.9)\r\n                    dx, dy = x2 - x1, y2 - y1\r\n                    length = (dx**2 + dy**2)**0.5\r\n                    if length > 0:\r\n                        dx_norm, dy_norm = dx / length, dy / length\r\n                        self.ax.arrow(x1 + 0.7*dx, y1 + 0.7*dy, dx_norm*0.05, dy_norm*0.05,\r\n                                    head_width=0.09, head_length=0.09, fc=colors[net_id], ec=colors[net_id])\r\n                    # dodavanje koordinata za source/sink label\r\n                    if i == 0:\r\n                        x_coords.append(x1)\r\n                        y_coords.append(y1)\r\n                    x_coords.append(x2)\r\n                    y_coords.append(y2)\r\n                    break  # preskoci dalje, ne crtamo iz SINK-a\r\n                \r\n                dx = x2 - x1\r\n                dy = y2 - y1\r\n                length = (dx ** 2 + dy ** 2) ** 0.5\r\n                dx_norm, dy_norm = (dx / length, dy / length) if length > 0 else (0, 0)\r\n                \r\n                \r\n                if node1.type in ['CHANX', 'CHANY'] and node2.type in ['CHANX', 'CHANY'] and node1.type != node2.type:\r\n                    \r\n                    turn_x = x2 if node1.type == 'CHANX' else x1\r\n                    turn_y = y1 if node1.type == 'CHANX' else y2\r\n                    self.ax.plot([x1, turn_x], [y1, turn_y], color=colors[net_id], linewidth=2, alpha=0.9)\r\n                    self.ax.plot([turn_x, x2], [turn_y, y2], color=colors[net_id], linewidth=2, alpha=0.9)\r\n\r\n                    # strelice za L-shape\r\n                    seg1_dx, seg1_dy = turn_x - x1, turn_y - y1\r\n                    seg1_length = (seg1_dx ** 2 + seg1_dy ** 2) ** 0.5\r\n                    seg1_dx_norm = seg1_dx / seg1_length if seg1_length > 0 else 0\r\n                    seg1_dy_norm = seg1_dy / seg1_length if seg1_length > 0 else 0\r\n                    arrow_positions.append((x1 + 0.7*seg1_dx, y1 + 0.7*seg1_dy, seg1_dx_norm, seg1_dy_norm))\r\n\r\n                    seg2_dx, seg2_dy = x2 - turn_x, y2 - turn_y\r\n                    seg2_length = (seg2_dx ** 2 + seg2_dy ** 2) ** 0.5\r\n                    seg2_dx_norm = seg2_dx / seg2_length if seg2_length > 0 else 0\r\n                    seg2_dy_norm = seg2_dy / seg2_length if seg2_length > 0 else 0\r\n                    arrow_positions.append((turn_x + 0.7*seg2_dx, turn_y + 0.7*seg2_dy, seg2_dx_norm, seg2_dy_norm))\r\n                else:\r\n                    \r\n                    self.ax.plot([x1, x2], [y1, y2], color=colors[net_id], linewidth=2, alpha=0.9)\r\n                    arrow_positions.append((x1 + 0.7*dx, y1 + 0.7*dy, dx_norm, dy_norm))\r\n                \r\n        \r\n                if i == 0:\r\n                    x_coords.append(x1)\r\n                    y_coords.append(y1)\r\n                x_coords.append(x2)\r\n                y_coords.append(y2)\r\n                drawn_edges.add((node_id1, node_id2))\r\n                \r\n        \r\n            for arrow_x, arrow_y, dx_norm, dy_norm in arrow_positions:\r\n                if dx_norm != 0 or dy_norm != 0:\r\n                    tail_length = 0.05\r\n                    self.ax.arrow(arrow_x, arrow_y, dx_norm*tail_length, dy_norm*tail_length,\r\n                                head_width=0.09, head_length=0.09, fc=colors[net_id], ec=colors[net_id])\r\n\r\n            \r\n            #po jedan samo ispise\r\n            # self.ax.text(x_coords[0], y_coords[0]-0.3, f\"S-{net_id}\",\r\n            #             ha='center', va='center', fontsize=7,\r\n            #             bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"lightblue\"))\r\n\r\n\r\n            # sink_nodes = [node_id for node_id in routing_path if rrg.nodes[node_id].type == \"SINK\"]\r\n            # for node_id in sink_nodes:\r\n            #     x, y = self.coord_map[node_id]\r\n            #     self.ax.text(x, y-0.3, f\"E-{net_id}\",\r\n            #                 ha='center', va='center', fontsize=7,\r\n            #                 bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=\"lightgreen\"))\r\n            \r\n            #deo sa offsetom - nabaca sve nodes koji su tu \r\n            nodes_list = [rrg.nodes[node_id] for node_id in routing_path]\r\n            for i, node in enumerate(nodes_list):\r\n                if node.type in ['SOURCE', 'SINK']:\r\n                    x_pos = self.coord_map[node.id][0]\r\n                    y_pos = self.coord_map[node.id][1]\r\n                    position_key = (x_pos, y_pos)\r\n\r\n                    # proverimo da li je pozicija vec koriscena\r\n                    if position_key in labeled_positions:\r\n                        # ako jeste, pomerimo na dole malo da ne dodje do preklapanja\r\n                        offset = labeled_positions[position_key] * -0.25\r\n                        labeled_positions[position_key] += 1\r\n                    else:\r\n                        # ako nije samo postavimo\r\n                        offset = 0\r\n                        labeled_positions[position_key] = 1\r\n\r\n                    label_text = f\"S-{net_id}\" if node.type == 'SOURCE' else f\"E-{net_id}\"\r\n                    facecolor = \"lightblue\" if node.type == 'SOURCE' else \"lightgreen\"\r\n\r\n                    self.ax.text(x_pos, y_pos + offset - 0.3, label_text,\r\n                                 ha=\"center\", va=\"center\", fontsize=8,\r\n                                 bbox=dict(boxstyle=\"round,pad=0.2\", facecolor=facecolor))\r\n\r\n    def hpwl_all_signals(self, rrg: RRG, route):\r\n\r\n        hpwl_results = {}\r\n\r\n        for net_id, net in route.nets.items():\r\n\r\n            nodes = net.nodes\r\n            x_coords, y_coords = [], []\r\n\r\n            for node in nodes:\r\n                if node.id in self.coord_map:\r\n                    x, y = self.coord_map[node.id]\r\n                    x_coords.append(x)\r\n                    y_coords.append(y)\r\n                else:\r\n                    try:\r\n                        start_clb_x = self.io_size + self.io_clb_gap\r\n                        start_clb_y = self.io_size + self.io_clb_gap\r\n                        x, y = self.calculate_node_position(node, start_clb_x, start_clb_y)\r\n\r\n                        if x is not None and y is not None:\r\n                            x_coords.append(x)\r\n                            y_coords.append(y)\r\n                            self.coord_map[node.id] = (x, y)\r\n                    except:\r\n                        print(f\"Nije moguce dobiti koordinatu za cvor {node.id}\")\r\n                        continue\r\n\r\n            if x_coords and y_coords:\r\n                x_min, x_max = min(x_coords), max(x_coords)\r\n                y_min, y_max = min(y_coords), max(y_coords)\r\n                hpwl = (x_max - x_min) + (y_max - y_min)\r\n                hpwl_results[net_id] = hpwl\r\n            else:\r\n                hpwl_results[net_id] = 0\r\n                print(f\"Signal {net_id} nema validnih koordinata\")\r\n\r\n        return hpwl_results\r\n\r\n    def save_hpwl(self, hpwl_results, filename=\"hpwl_metrika.txt\"):\r\n        try:\r\n            with open(filename, 'w', encoding='utf-8') as f:\r\n                f.write(\"HPWL METRIKA\\n\")\r\n                f.write(\"*\" * 25 + \"\\n\")\r\n\r\n                total_hpwl = 0\r\n                for net_id, hpwl in hpwl_results.items():\r\n                    f.write(f\"Signal {net_id}: HPWL = {hpwl:.2f}\\n\")\r\n                    total_hpwl += hpwl\r\n\r\n                avg_hpwl = total_hpwl / len(hpwl_results) if hpwl_results else 0\r\n                max_hpwl = max(hpwl_results.values()) if hpwl_results else 0\r\n                min_hpwl = min(hpwl_results.values()) if hpwl_results else 0\r\n\r\n                f.write(\"\\n\" + \"*\" * 25 + \"\\n\")\r\n                f.write(f\"Ukupan HPWL: {total_hpwl:.2f}\\n\")\r\n                f.write(f\"Prosečan HPWL: {avg_hpwl:.2f}\\n\")\r\n                f.write(f\"Maksimalni HPWL: {max_hpwl:.2f}\\n\")\r\n                f.write(f\"Minimalni HPWL: {min_hpwl:.2f}\\n\")\r\n                f.write(\"*\" * 25 + \"\\n\")\r\n\r\n            print(f\"HPWL metrike su sačuvane u fajl: {filename}\")\r\n\r\n        except Exception as e:\r\n            print(f\"Greška pri snimanju HPWL metrika u fajl: {e}\")\r\n\r\n    # default neka bude 5, a moze se pozivati i vise naravno, dole imamo ogranicenje ako korisnik zeli vise signala nego sto je dostupno\r\n    def get_signals_with_largest_bboxes(self, rrg: RRG, route, top_n = 5):\r\n\r\n        signal_bboxes = []\r\n\r\n        for net_id, net in route.nets.items():\r\n            x_coords, y_coords = [], []\r\n\r\n            for node in net.nodes:\r\n                if node.id in self.coord_map:\r\n                    x, y = self.coord_map[node.id]\r\n                    x_coords.append(x)\r\n                    y_coords.append(y)\r\n                else:\r\n                    try:\r\n                        start_clb_x = self.io_size + self.io_clb_gap\r\n                        start_clb_y = self.io_size + self.io_clb_gap\r\n                        x, y = self.calculate_node_position(node, start_clb_x, start_clb_y)\r\n\r\n                        if x is not None and y is not None:\r\n                            x_coords.append(x)\r\n                            y_coords.append(y)\r\n                            self.coord_map[node.id] = (x, y)\r\n                    except:\r\n                        print(f\"Nije moguce dobiti koordinatu za cvor {node.id}\")\r\n                        continue\r\n\r\n            if x_coords and y_coords:\r\n                x_min, x_max = min(x_coords), max(x_coords)\r\n                y_min, y_max = min(y_coords), max(y_coords)\r\n                width = x_max - x_min\r\n                height = y_max - y_min\r\n                area = width * height\r\n\r\n                bbox_coords = (x_min, y_min, x_max, y_max)\r\n                signal_bboxes.append((net_id, bbox_coords, area))\r\n\r\n        signal_bboxes.sort(key=lambda x : x[2], reverse=True)\r\n\r\n        if top_n > len(signal_bboxes):\r\n            print(f\"Greska, dostupno je {len(signal_bboxes)} signala\")\r\n            return False\r\n\r\n        return True, signal_bboxes[:top_n]\r\n\r\n\r\n    def visualize_largest_bboxes(self, largest_bboxes):\r\n\r\n        if not largest_bboxes:\r\n            print(\"Greska, nema signala sa validnim bounding boxom\")\r\n            return\r\n\r\n        colors = plt.cm.tab10.colors\r\n\r\n        for i, (net_id, bbox_coords, area) in enumerate(largest_bboxes):\r\n            x_min, y_min, x_max, y_max = bbox_coords\r\n            width = x_max - x_min\r\n            height = y_max - y_min\r\n\r\n            bbox = patches.Rectangle(\r\n                (x_min, y_min), width, height,\r\n                linewidth=2, edgecolor=colors[i % len(colors)],\r\n                facecolor='none', linestyle='--', alpha=0.8\r\n            )\r\n            self.ax.add_patch(bbox)\r\n\r\n            label = f\"Net {net_id}\\nOblast: {area:.2f}\"\r\n            self.ax.text(\r\n                x_min + width/ 3, y_min - 0.5, label,\r\n                ha='center', va='top',\r\n                bbox=dict(boxstyle=\"round,pad=0.3\", facecolor=colors[i % len(colors)], alpha=0.7),\r\n                fontsize=8\r\n            )\r\n    \r\n   \r\n   \r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fpga_project/fpga_routing.py b/fpga_project/fpga_routing.py
--- a/fpga_project/fpga_routing.py	(revision 70cd47f31149bf01fe4b68e16b80e405a47091a4)
+++ b/fpga_project/fpga_routing.py	(date 1757697400972)
@@ -483,6 +483,6 @@
                 bbox=dict(boxstyle="round,pad=0.3", facecolor=colors[i % len(colors)], alpha=0.7),
                 fontsize=8
             )
-    
+
    
    
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"c89fa435-cae2-43e8-ae0e-3967b1bfdc1a\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/fpga_project/fpga_routing.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/fpga_project/fpga_routing.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/parse_all.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/parse_all.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"FlaskConsoleOptions\" custom-start-script=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\">\r\n    <envs>\r\n      <env key=\"FLASK_APP\" value=\"app\" />\r\n    </envs>\r\n    <option name=\"myCustomStartScript\" value=\"import sys&#10;sys.path.extend([WORKING_DIR_AND_PYTHON_PATHS])&#10;from flask.cli import ScriptInfo&#10;locals().update(ScriptInfo(create_app=None).load_app().make_shell_context())&#10;print(&quot;Python %s on %s\\nApp: %s [%s]\\nInstance: %s&quot; % (sys.version, sys.platform, app.import_name, app.env, app.instance_path))\" />\r\n    <option name=\"myEnvs\">\r\n      <map>\r\n        <entry key=\"FLASK_APP\" value=\"app\" />\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 0\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"31xlmCp0TcWWboFj0cIOtTRnH9E\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python.parse_all.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"dart.analysis.tool.window.visible\": \"false\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"ignore.virus.scanning.warn.message\": \"true\",\r\n    \"last_opened_file_path\": \"E:/PMF/PRIS/pris-project\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"inlay.hints\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-5c90d61e3bab-JavaScript-PY-242.23726.102\" />\r\n        <option value=\"bundled-python-sdk-5e1850174b45-399fe30bd8c1-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-242.23726.102\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"c89fa435-cae2-43e8-ae0e-3967b1bfdc1a\" name=\"Changes\" comment=\"\" />\r\n      <created>1756473760262</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1756473760262</updated>\r\n      <workItem from=\"1756473761332\" duration=\"8990000\" />\r\n      <workItem from=\"1756541101601\" duration=\"7111000\" />\r\n      <workItem from=\"1756552776889\" duration=\"323000\" />\r\n      <workItem from=\"1756647320963\" duration=\"3439000\" />\r\n      <workItem from=\"1756650909369\" duration=\"1274000\" />\r\n      <workItem from=\"1757152967267\" duration=\"5222000\" />\r\n      <workItem from=\"1757167170592\" duration=\"6073000\" />\r\n      <workItem from=\"1757253854310\" duration=\"8100000\" />\r\n      <workItem from=\"1757325679020\" duration=\"16462000\" />\r\n      <workItem from=\"1757347263650\" duration=\"120000\" />\r\n      <workItem from=\"1757413537862\" duration=\"7777000\" />\r\n      <workItem from=\"1757421819078\" duration=\"992000\" />\r\n      <workItem from=\"1757517915069\" duration=\"126000\" />\r\n      <workItem from=\"1757690320916\" duration=\"6937000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/pris_project$parse_all.coverage\" NAME=\"parse_all Coverage Results\" MODIFIED=\"1756491053108\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 70cd47f31149bf01fe4b68e16b80e405a47091a4)
+++ b/.idea/workspace.xml	(date 1757697422235)
@@ -6,7 +6,6 @@
   <component name="ChangeListManager">
     <list default="true" id="c89fa435-cae2-43e8-ae0e-3967b1bfdc1a" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/fpga_project/fpga_routing.py" beforeDir="false" afterPath="$PROJECT_DIR$/fpga_project/fpga_routing.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/parse_all.py" beforeDir="false" afterPath="$PROJECT_DIR$/parse_all.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -88,7 +87,7 @@
       <workItem from="1757413537862" duration="7777000" />
       <workItem from="1757421819078" duration="992000" />
       <workItem from="1757517915069" duration="126000" />
-      <workItem from="1757690320916" duration="6937000" />
+      <workItem from="1757690320916" duration="7028000" />
     </task>
     <servers />
   </component>
